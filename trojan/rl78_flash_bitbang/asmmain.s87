;----------------------------------------------------
;       
;       This is a template file.
;
;       Copyright 2011 IAR Systems AB.
;
;       $Revision: $
;
;----------------------------------------------------
        NAME    asmmain           ; Label this program

        RSEG    CSTACK

        //Default linker script likes putting this at 0xD8
        //Modified to point at 0x100
        //Not sure how that relates to ASEGN which places reset vector
        ASEGN   RCODE:CODE, 0x0000
        DW      asmmain           ; Reset vector
        public orig_F07F9
        public asmmain
        RSEG    CODE


        //Ported from C code
        public delay_ms_loop2
delay_ms:
        CMPW      AX, #0x0
        PUSH      DE
        MOVW      DE, #0x0
        BZ        delay_ms_loop2
delay_ms_loop0:
        MOVW      HL, #0x52D
delay_ms_loop1:
        DECW      HL
        XCHW      AX, HL
        CMPW      AX, #0x0
        NOP
        XCHW      AX, HL
        BNZ       delay_ms_loop1
        INCW      DE
        CMPW      AX, DE
        SKZ
        BNC       delay_ms_loop0
delay_ms_loop2:
        POP       DE
        RET



delay_block:
        MOVW      AX, #0x0A
        call delay_ms
        RET

delay_char:
        MOVW      AX, #0x01
        call delay_ms
        RET
        
        MOV      A, #0xFF
delay_small_loop0:
        DEC       A
        NOP
        NOP
        NOP
        NOP
        NOP
        BNZ       delay_small_loop0
        RET


        //Ported from C code
send_byte:
        PUSH      BC
        PUSH      DE
        PUSH      AX
        SUBW      SP, #0xC
        CLRB      A
        MOV       [SP], A
        ONEB      A
        MOV       [SP+0x09], A
        MOV       [SP+0x0A], A
        MOV       [SP+0x0B], A
        MOVW      AX, SP
        SET1      S:0xFFF04.0
        MOVW      DE, AX
        INCW      DE
        MOV       B, #0x4

send_byte_0:
        MOVW      AX, SP
        ADDW      AX, #0xD
        MOVW      HL, AX
        MOV       A, [HL]
        AND       A, #0x1
        MOV       [DE], A
        MOV       A, [SP+0x0D]
        SHR       A, 0x1
        MOV       [SP+0x0D], A
        AND       A, #0x1
        MOV       [DE+0x01], A
        MOV       A, [SP+0x0D]
        SHR       A, 0x1
        INCW      DE
        DEC       B
        MOV       [SP+0x0D], A
        INCW      DE
        BNZ       send_byte_0
        MOVW      AX, SP
        MOVW      HL, AX
        MOV       X, #0xC

send_byte_1:
        MOV1      CY, [HL].0
        MOV1      S:0xFFF07.7, CY
        MOV1      CY, [HL].0
        MOV1      S:0xFFF04.0, CY
        MOV       A, #0x84

send_byte_2:
        DEC       A
        NOP
        BNZ       send_byte_2
        DEC       X
        INCW      HL
        BNZ       send_byte_1
		; 0xC buffer + temporary AX argument storage
        ADDW      SP, #0xE
        POP       DE
        POP       BC
        RET       



blinky:
        //mov a, #200
        MOVW      AX, #0x64
        call delay_ms

        //LED toggle
        MOV1      CY, 0xFFF07.7
        NOT1      CY
        MOV1      0xFFF07.7, CY
        ;SET1      S:0xFFF07.7
        
        ;MOVW      AX, #0xAA
        ;MOV      A, #0xAA
        ;call send_byte

        br        blinky










asmmain:
        mov     es, #0 ; clear registers for memory addressing
        movw    de, #0
        nop
    
        // Conifgure LED pullup
        // PU7_bit.no7 = 1;
        // 000000 363700                MOVW      HL, #0x37
        MOVW      HL, #0x37
        // 000003 71F2                  SET1      [HL].7
        SET1      [HL].7
    
        // Configure LED as output
        // PM7_bit.no7 = 0;
        // 000005 717B27                CLR1      0xFFF27.7
        CLR1      0xFFF27.7
        // LED on
        CLR1      0xFFF07.7

      //NRZ high
        SET1      S:0xFFF04.0
      //TOOL0 as output
      //PM4_bit.no0 = 0;
      CLR1      0xFFF24.0


		/*
        MOV1      CY, 0xFFF07.7
        NOT1      CY
        MOV1      0xFFF07.7, CY

        MOV1      CY, 0xFFF07.7
        NOT1      CY
        MOV1      0xFFF07.7, CY

        //SET1      S:0xFFF07.7
        BR $
		*/



        // set1    byte_F0090.0  // enabled access to data flash, just setting everytime as its easier to fit in asm
        //Error[As025]: Limit exceeded: Allowed range is 0xffe20 - 0xfff1f (1048096 - 1048351), value is 0xf0090 (983184)
        //set1    S:0xF0090.0
        //XXX: do we need to set ES explicitly?
        //is this clashing with our specific ES control?
        //disassemble and look carefuly at how these interact
        //What exactly is this register?
        ;set1    ES:0xF0090.0
        set1    0xF0090.0
        ;call blinky
  
        ; C code version
        ;MOV       L, #0x90
        ;SET1      [HL].0


        movw ax, #100
        call delay_ms

#if 0
test1:
        mov a, #0
        call send_byte

        mov     es, #0000h
        movw    de, #0100h
        mov     a, es:[de]
        call send_byte

        mov     es, #0000h
        movw    de, #0101h
        mov     a, es:[de]
        call send_byte

        mov     es, #0000h
        movw    de, #0102h
        mov     a, es:[de]
        call send_byte

        mov     es, #0000h
        movw    de, #0103h
        mov     a, es:[de]
        call send_byte
      
        br test1
#endif

      /*
      Data flash
      */
        mov     es, #0 ; clear registers for memory addressing
        movw    de, #0


    /*
R5F100AC
Code Flash (Address : 0x00000000,  Size : 32 K,  Erase Size : 1 K)
Data Flash (Address : 0x000F1000,  Size : 4 K,  Erase Size : 1 K)
    */
        //mov     es, #0x000F ; clear registers for memory addressing
        //movw    de, #0x1000
    
        mov     es, #0x0008
        movw    de, #0x0000

orig_F07E6:

        /*
        //LED toggle
        MOV1      CY, 0xFFF07.7
        NOT1      CY
        MOV1      0xFFF07.7, CY

        movw ax, #10
        call delay_ms
        space out every 0x100 bytes
        */
        movw ax, de
        SHLW ax, 8
        cmp    a, #0

        public skip_delay
        bnz     skip_delay
        call delay_block
skip_delay:

        ;mov     a, es:[de]  ; index memory 1 byte at a time and move to accumulator
        ;call    sub_EFFA1   ; call tool_tx to send byte in reg A over tool0 wire
        //call !!0x0effa1
        ;movw ax, #0
        mov     a, es:[de]  ; index memory 1 byte at a time and move to accumulator
        ;MOV      A, #0xAA
        call send_byte
        incw    de      ; increment de till full 0xffff wraps to 0
        movw    ax, de
        cmpw    ax, #0    
        
        bnz     orig_F07E6   ; if de hasnt wrapped keep dumping
        br      orig_F07F9     ; if it has, go to es inc routine
        
        ; ? w/e see if it works w/o this
        ;  0x55          ; overwrites ocd flag!
        ; nop                   
        ;mov d, #0
        nop
        nop
        
orig_F07F9:
        ;call blinky
        
        mov     a, es
        inc     a
        and     a, #0x0F   ; if es is addressing 0xfxxxx we are at last addressable region
        mov     es, a     ; set es with incremented range


        br      orig_F07E6
        

        STOP                      ; End of program
        NOP

        END     asmmain
